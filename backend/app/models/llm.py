"""SQLAlchemy model for suggestions generated by the LLM service."""

from __future__ import annotations

import json
from datetime import datetime
from typing import List, Optional

from sqlalchemy import Column, DateTime, ForeignKey, Integer, String, Text

from app.db.base import Base


class LLMSuggestion(Base):
    """Persistence model storing the output of the Ollama powered LLM."""

    __tablename__ = "llm_suggestions"

    id: int = Column(Integer, primary_key=True, autoincrement=True, index=True)

    # Optional FK to the job that produced the transcript
    job_id: Optional[int] = Column(Integer, ForeignKey("processing_jobs.id", ondelete="SET NULL"))

    prompt_type: str = Column(String(50), nullable=False)
    model_used: Optional[str] = Column(String(100), nullable=True)

    # Store titles as JSON inside a TEXT column for portability across DBs
    _titles_json: Optional[str] = Column("titles", Text, nullable=True)

    suggested_summary: Optional[str] = Column(Text, nullable=True)

    created_at: datetime = Column(DateTime(timezone=True), nullable=False, default=datetime.utcnow)

    # ------------------------------------------------------------------
    # Convenience helpers
    # ------------------------------------------------------------------

    def set_titles(self, titles: List[str] | None) -> None:
        """Persist a list of titles as JSON string."""

        self._titles_json = json.dumps(titles or [])

    def get_titles(self) -> List[str]:
        """Return titles as list even if DB value is NULL/empty."""

        if not self._titles_json:
            return []
        try:
            return json.loads(self._titles_json)
        except json.JSONDecodeError:
            # Gracefully degrade – shouldn't happen, but we don't want the
            # entire request to fail because of one malformed row.
            return []

    # SQLAlchemy calls __init__ and passes keyword args – expose friendly ones
    def __init__(
        self,
        job_id: Optional[int] = None,
        prompt_type: str | None = None,
        model_used: str | None = None,
        titles: Optional[List[str]] = None,
        suggested_summary: str | None = None,
        **kwargs,
    ) -> None:  # noqa: D401 – not a docstring style check

        super().__init__(
            job_id=job_id,
            prompt_type=prompt_type or "title_summary",
            model_used=model_used,
            suggested_summary=suggested_summary,
            **kwargs,
        )

        # Use the helper to ensure correct serialisation
        self.set_titles(titles)
